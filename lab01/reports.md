# <center>实验1：调试分析 Linux 0.00 引导程序<center/>

## 1.简述head.s的工作原理

head.s 程序运行在 32 位保护模式下，其中主要包括初始设置的代码、时钟中断 int 0x08 的过程代码、 系统调用中断 int 0x80 的过程代码以及任务 A 和任务 B 等的代码和数据。其中初始设置工作主要包括： ①重新设置 GDT 表；②设置系统定时器芯片；③重新设置 IDT 表并且设置时钟和系统调用中断门；④移动到任务 A 中执行。

head.s实现了两个运行在特权级 3 上的任务在时钟中断控制下相互切换运行，并且还实现了在屏幕上显示字 符的一个系统调用。我们把这两个任务分别称为任务 A 和任务 B（或任务 0 和任务 1），它们会调用这个显示系统调用在屏幕上分别显示出字符'A'和'B'，直到每个 10 毫秒切换到另一个任务。任务 A 连续循环地调用系统调用在屏幕上显示字符'A'；任务 B 则一直显示字符'B'。

当程序跳转到head.s的第一条指令后，head.s首先进行数据段和栈段的初始化（因为boot.s中仅利用GDT初始化了CS），随后调用setup_idt与setup_gdt进行GDT与IDT初始化（相应表项都在程序中），在设置时钟中断请求信号后，在IDT第8与第128项设置定时中断门描述符和系统调用陷阱门描述符（以打印字符）。一切就绪后，由于此时是内核态，不能直接切换成用户态，但反过来可以，因此向栈中压入一些寄存器模拟内核态返回用户态场景，利用iret指令即可跳入A任务代码段执行。10ms一次切换，如此往复。当出现一个其他中断时，系统就会 运行默认中断处理程序，于是就会在屏幕上显示一个字符'C'，然后退出中断。

## 2.head.s内存分布状况

head.s内存分布状况大致如下图：

![image-20230505215615925](.\images\img1.png)

在setup_gdt调用完毕后，GDT如下图：

![image-20230505215721112](.\images\img2.png)

因此，内核代码段起始位置为0x0，终止位置为0x7FFFFF，内核数据段起始位置为0x0，终止位置为0x7FFFFF。

如图所示，各个段寄存器值如下，ss寄存器为0x10，与数据段相同，因此内核栈起始位置为0x0，终止位置为0x7FFFFF。

![image-20230505220712379](.\images\img3.png)

由上图可知任务0的LDT位于0xBE0位置，查看内存得：

![image-20230505222200614](.\images\img4.png)

由此可以得到任务0代码段起始位置为0x0，终止位置为0x3FFFFF，同理数据段起始位置为0x0，终止位置为0x3FFFFF。

TSS0位于0xBF8，查看内存：

![image-20230505223111939](.\images\img5.png)

可以看得出，只有ss0是0x10，其他两个都是0x0，未被初始化状态，由于选择了GDT，因此任务0内核栈与之前一样，起始位置为0x0，终止位置为0x7FFFFF；与此同时，在人为构造中断返回后，此时ss寄存器为0x17，语义为用户态LDT第2项，由前文可知，任务0用户栈起始位置为0x0，终止位置为0x3FFFFF。

任务1LDT位于0xE60，查看内存得：

![image-20230505225821437](.\images\img6.png)

同任务0理由，代码段起始位置为0x0，终止位置为0x3FFFFF，同理数据段起始位置为0x0，终止位置为0x3FFFFF。

TSS1位于0xE78：

![image-20230505230031331](.\images\img7.png)

ss0依旧为0x10，任务1内核栈起始位置为0x0，终止位置为0x7FFFFF；这次与上次不同，TSS里的ss不再是0x0，不过还是0x17就是了，因此任务1用户栈起始位置为0x0，终止位置为0x3FFFFF。

综上，结果如下：

|            | 代码段       | 数据段       | 内核栈       | 用户栈       |
| ---------- | ------------ | ------------ | ------------ | ------------ |
| head.s内核 | 0x0-0x7FFFFF | 0x0-0x7FFFFF | 0x0-0x7FFFFF |              |
| 任务0      | 0x0-0X3FFFFF | 0x0-0x3FFFFF | 0x0-0x7FFFFF | 0x0-0x3FFFFF |
| 任务1      | 0x0-0X3FFFFF | 0x0-0x3FFFFF | 0x0-0x7FFFFF | 0x0-0x3FFFFF |

除此之外，GDT选择子0x18指示了显存段，起始地址为0xB8000，终止地址为0xBAFFF。

## 3.`head.s` `57` 至 `62` 行所做之事

由于处于特权级 0 的代码不能直接把控制权转移到特权级 3 的代码中执行，但中断返回操作是可以的， 因此当初始化 GDT、IDT 和定时芯片结束后，利用中断返回指令 IRET 来启动运行任务0。具体实现方法就是57至62行，在初始堆栈 init_stack 中人工设置一个返回环境。把任务 0 的 TSS 段选择符加载到任务寄存器 LTR 中、LDT 段选择符加载到 LDTR 中以后，把任务 0 的用户栈指针（0x17:init_stack）和代码指针 （0x0f:task0）以及标志寄存器值压入栈中，然后执行中断返回指令 IRET。该指令会弹出堆栈上的堆栈指 针作为任务0用户栈指针，恢复假设的任务0的标志寄存器内容，并且弹出栈中代码指针放入CS:EIP寄存器中，从而开始执行任务 0 的代码，完成了从特权级 0 到特权级 3 代码的控制转移。

## 4.`iret` 执行后， `pc` 如何找到下一条指令

由于在中断返回前进行了人工压栈操作，因此iret指令在执行时，会将原先栈中内容弹出，其中也包括task0与0x0f，这两个分别为任务0首条代码标号以及CS段，并被分别赋值为eip以及CS寄存器，有了这两个值，就可以先通过cs=0x0f=0b00001111到LDT中寻找相应代码段初始地址（上文提过），与eip（也就是task0标号）相加就可以找到下一条指令地址。

<img src=".\images\img8.png" alt="image-20230505232353790" style="zoom:80%;" />

## 5.`iret` 执行前后，栈是如何变化的

执行前栈：

![image-20230505232504365](.\images\img9.png)

执行后栈：

![image-20230505232603922](.\images\img10.png)

可以发现，iret指令执行前后，ss寄存器以及esp内容都发生了变化，并且可以发现变化后的这两个值原来都被预先压到了栈中，因此可以得出结论，iret指令会根据原先栈中内容将其弹出并且赋给变化后的栈。由上文可以知道，0x17对应的基地址为0x0，加上0xbd8则为0xbd8，与图中一致。

## 6.`int 0x80` 时，记录栈的变化情况

调用前：

![image-20230505233211316](.\images\img11.png)

调用后：

![image-20230505233352513](.\images\img12.png)

可以发现，ss变为0x10，即切换到了内核栈，进入内核模式。并且可以发现，栈顶的内容恰好是调用前cs,ss,eip,eflag,esp内容，这与之前人工构造中断返回场景（顺序）一致，说明在进入中断程序时需要先将系统状态保存在栈中。还有一个细节，查看IDT发现0x80项为：

<img src=".\images\img13.png" alt="image-20230505233742979" style="zoom:50%;" />

与当前指令地址一致，说明IDT存储了中断程序入口地址。

一系列寄存器压栈以及调用某个函数后：

![image-20230505234006308](.\images\img14.png)

发现栈顶除了先前压进的寄存器值，还有执行调用语句的下一条指令的地址，也就是当前程序的返回地址；返回后返回地址弹出，当前指令指针重新设置为0x177：

![image-20230505234152830](.\images\img15.png)

iret后，与段信息有关的先前被压入的寄存器弹出恢复状态，各寄存器被恢复为进入中断前的值，与之前人工iret行为一致：

![image-20230505234311997](.\images\img16.png)

以上就是int 0x80全过程。