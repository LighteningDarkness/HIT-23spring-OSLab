# <center>实验3. 操作系统的引导<center/>

## 1.有时，继承传统意味着别手蹩脚。 `x86` 计算机为了向下兼容，导致启动过程比较复杂。 请找出 `x86` 计算机启动过程中，被硬件强制，软件必须遵守的两个“多此一举”的步骤（多找几个也无妨），说说它们为什么多此一举，并设计更简洁的替代方案。

1. 实模式与保护模式的切换：在启动过程中，x86 CPU一开始处于实模式下，然后需要切换到保护模式，这个切换过程涉及到一系列复杂的操作。这一步骤被认为是多此一举，因为在现代操作系统中，大部分时候都是在保护模式下运行，实模式几乎不会被使用。这个切换过程增加了启动时间和复杂性。替代方案：设计一种新的计算机体系结构，从一开始就直接进入保护模式。这样可以避免实模式和保护模式切换的开销，简化启动过程。
2. 无论是Linux 0.00还是0.11，都是先将引导扇区读入 0x7c00 处，然后跳到 0x7c00 开始执行，接着，为了方便后面程序的加载与运行，又会将自己移动后靠后的位置。解决方案：扩大BIOS可访问地址，避免二次移动影响启动速度。
3. 在BIOS初始化的时候，会在内存的初始位置放置1kb的中断向量表，来方便BIOS中断使用。 如果在主模块中需要使用一些由BIOS中断得到的硬件参数的情况下，就不能在主模块的加载开始过程中直接覆盖掉这1kb的中断向量表而让主模块直接从内存的初始位置加载（从内存的初始位置加载的话以后代码中的地址就是实际的地址，能极大的方便操作）。为了解决这个问题，在linux 0.11 中，会将system先加载到不与中断向量表冲突的地方，然后再将主模块移动到内存的初始位置，再将这个中断向量表覆盖掉。解决方案：1kb的中断向量表不放在内存的初始位置，而是放到其他实模式下能够寻址的其他地方。 这样操作系统的system模块就会直接加载到内存的初始位置。
4. 实模式段寄存器设置：在实模式下，x86 CPU使用段寄存器来定位内存中的代码和数据。启动过程中，需要设置段寄存器的值，以便正确加载引导程序和操作系统。然而，这种段寄存器的设置在现代操作系统中几乎没有实际意义，因为大部分操作系统都在保护模式下运行，使用分页机制来管理内存。实模式下的段寄存器设置可以被认为是多余的，增加了启动过程的复杂性。解决方案：设计一种新的计算机体系结构，不依赖于实模式下的段寄存器设置。可以通过在启动过程中直接进入保护模式，并使用更现代的内存管理机制，如分页机制，来简化启动过程。

## 2.实验结果

![image-20230520161254471](.\images\img1.png)

## 3.简单记录

### 3.1 int 0x10

这个实验一大难点就是int 0x10使用，int 0x10 是BIOS对屏幕及显示器所提供的服务程序。使用int 0x10中断服务程序时，先要进行一些简单的配置，比如指定功能号和子功能号。其中寄存器AH表示的就是功能号，在不同功能下不同寄存器可能有不同的功能，这里不赘述，例如03H号功能：在文本坐标下，读取光标各种信息，入口参数：AH＝03H，BH＝显示页码，出口参数：CH＝光标的起始行，CL＝光标的终止行，DH＝行(Y坐标)，DL＝列 (X坐标)，显示模式为07H，即黑底白字。

## 3.2 几个细节

- 在输出自己的信息时，别忘了字符串长度得加上几个\r\n

  ![image-20230622225216692](.\images\img2.png)

- 最后得死循环，否则会乱跳

- 调用int 0x10时，ES寄存器需要正确赋值，否则显示会混乱